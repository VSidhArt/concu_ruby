# Concu Ruby
Simple project for play `Concurrency` in `Ruby`.

## Подготовка

- install ruby 2.6.1
- bundle install

## Сервер
В комплект входит сервер, написанный на `Falcon`.

Его надо запускать командой `falcon serve -c config.ru --threaded`
Именно в режиме `threaded`.

Сервер предоставляет три эндпоинта: `a`, `b`, `c`.

- `a` отвечает за `1 секунду`
- `b` отвечает за `2 секунды`
- `c` отвечает за `3 секунды`

### Защита от перегрева
Эндпоинты можно вызывать несколько раз одновременно, но в них есть "защита от перегрева".

Если эндпоинт вызывается слишком интенсивно, то запрос, вызвавший перегрев, засыпает на длительное время, чтобы дать серверу охладится. После завершения ожидания клиент получает корректный ответ.

Ограничения на перегрев такие:

- `a` - одновременно может выполняться `3 экземпляра`
- `b` - одновременно может выполняться `2 экземпляра`
- `c` - одновременно может выполняться `1 экземпляр`

## Клиент
В комплект входит и клиент, который корректно решает поставленную задачу.
Он делает несколько запросов к серверу, как-то их комбинирует и выводит результат.

## Задача
Проблема в том, что референсное решение отрабатывает примерно `19,5 секунд`, а в задании требуется уложиться в `7 секунд`.

## Решение Futures
Использована библиотека `concurrent-ruby` и модудь `Promise` для неблокирующих вызовов, для ограничения количества запросов
`FixedThreadPool`. Решение отрабатывает за `6.3 секунды`

## Решение CSP(Communicating Sequential Processes)
Использована библиотека `concurrent-edge` и модудь `Channel`, аналог каналов в GoLang. Решение отрабатывает за `6.6 секунды`

## ToDo
- Ruby Treads and Queue
- `socketry/async`
- Ractor Ruby


